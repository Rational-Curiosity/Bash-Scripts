#!/bin/bash
set +e

IFS=$'\n'
PWDS=()
while [ "${1:0:1}" == "." -o "${1:0:1}" == "/" ]
do
    if [[ "$1" =~ ^\.+$ ]] && [ ${#1} -gt 2 ]
    then
        PWD="${1:2}"
        PWDS+=("$(realpath "${PWD//./..\/}..")")
    else
        PWDS+=("$(realpath "$1")")
    fi
    shift
done

if [ "${#PWDS[@]}" -eq 0 ]
then
    if [ -n "$CODEPATHS" ]
    then
        PWDS=("${CODEPATHS[@]}")
    elif [ -n "$CODEPATH" ]
    then
        PWDS=("$CODEPATH")
    else
        >&2 echo "Environment variable CODEPATH empty."
        exit 2
    fi
fi

EVAL_ECHO () {
    LAST_EXIT_CODE=$?
    eval "$@"
    exit $LAST_EXIT_CODE
}
CMD=(git --no-pager)
SYNC=false
EXIT=(EVAL_ECHO '>&2 echo "${magenta}Return code:$normal $LAST_EXIT_CODE"')
MAXDEPTH=3
VERBOSE=false
COLOR="always"
ECHO=(echo)
GGIT_COND=:
while [ "$#" -gt 0 ]
do
    case "$1" in
    --help)
        echo "usage: ggit [[./]PATH1 [./]PATH2 ..] [GGIT OPTIONS] [GIT OPTIONS]
  PATH<n>                   Optional path starting with . or /
                              to base repos folder,
                              default read CODEPATHS array
                              if empty read CODEPATH variable

                              ggit do replacements:
                                ...  -> ../../
                                .... -> ../../../
                                etc

  GGIT OPTIONS:
    --no-color|-n             Disable show colors.

    --if <bash condition>     Enter in repo folder and run git
                                if <bash condition>.
    --maxdepth|-d <number>    Max depth folder search .git folders
                                default 3.
    --continue|-c             Continue on git error, default stop.

    --sync|-s                 Running synchronously (async running
                                implies --continue)
    --processes|-p <number>   Number of asynchronous processes

    --retries|-r <number>     Number of retries

    --eval|-e                 Don't run git just run parameters.

    --quiet|-q                Minimal output.

    --verbose|-v              Show if false reason.

  GIT OPTIONS                 ggit do replacements:
                                {project}   ->  <repo folder name>
                                {date}      ->  `date '+%Y-%m-%d'`
                                {datetime}  ->  `date '+%Y-%m-%d_%H.%M.%S'`

Examples

  $ ggit --maxdepth 2 status
  $ ggit ... ~/repos status
  $ ggit --continue pull
  $ ggit --if 'ls setup.py' branch
  $ ggit bundle create ~/var/backup/{project}_{date}.bundle --all
  $ ggit grep -i signal \"\\\$(git rev-list --all)\"
  $ ggit --if \"rg -i api setup.py\" --quiet --eval pwd 2>/dev/null
  $ ggit --if 'test \"\$(git branch --show-current)\" != int' branch --show-current
  $ ggit --if \"git log --since=2020-05-01 --pretty=format:'%ae' | grep ctor\"\
 grep -iE --color=always '[ .]signal\(' \"\\\`git rev-list --all\\\`\" -- '*.py'
"
        exit
        ;;
    --no-color|-n)
        COLOR="never"
        shift
        ;;
    --if)
        shift
        GGIT_COND="$1"
        shift
        ;;
    --maxdepth|-d)
        shift
        MAXDEPTH="$1"
        shift
        ;;
    --continue|-c)
        EVAL_ECHO () {
            LAST_EXIT_CODE=$?
            eval "$@"
        }
        shift
        ;;
    --sync|-s)
        SYNC=true
        shift
        ;;
    --processes|-p)
        shift
        GGIT_PROCS="$1"
        shift
        ;;
    --retries|-r)
        shift
        GGIT_RETRIES="$1"
        shift
        ;;
    --eval|-e)
        CMD=""
        shift
        ;;
    --verbose|-v)
        VERBOSE=true
        ;;
    --quiet|-q)
        EVAL_QUIET () {
            :
        }
        ECHO=(EVAL_QUIET)
        shift
        ;;
    --*)
        >&2 echo "Unknown parameter: $1"
        exit 1
        ;;
    *)
        break
        ;;
    esac
done
if [ -z "$CMD" ]
then
    CMD=($1)
    shift
fi
PROCESSES="${GGIT_PROCS:-10}"
RETRIES="${GGIT_RETRIES:-3}"

PARAMS=("$@")
case "${PARAMS[0]}" in
push)
    SYNC=true
    ;;
esac


### [ <COLORES> ###
# check if stdout is a terminal...
if [ -t 1 ] || [ "$COLOR" == "always" ]
then
    # see if it supports colors...
    ncolors=$(tput colors)
    
    if [ -n "$ncolors" ] && [ $ncolors -ge 8 ]
    then
        bold="$(tput bold)"
        underline="$(tput smul)"
        standout="$(tput smso)"
        normal="$(tput sgr0)"
        black="$(tput setaf 0)"
        red="$(tput setaf 1)"
        green="$(tput setaf 2)"
        yellow="$(tput setaf 3)"
        blue="$(tput setaf 4)"
        magenta="$(tput setaf 5)"
        cyan="$(tput setaf 6)"
        white="$(tput setaf 7)"
    fi
fi
### ] <COLORES> ###


DATE="$(date '+%Y-%m-%d')"
DATETIME="$(date '+%Y-%m-%d_%H.%M.%S')"
if type fdfind >/dev/null 2>&1
then
    FINDER='fdfind -HI -t d -d $MAXDEPTH "^.git$" "$PWD"'
elif type fd-find >/dev/null 2>&1
then
    FINDER='fd-find -HI -t d -d $MAXDEPTH "^.git$" "$PWD"'
else
    FINDER='find "$PWD" ! -readable -prune -o -maxdepth $MAXDEPTH -type d -name .git -print 2>/dev/null'
fi

for PWD in "${PWDS[@]}"
do
    if [ ! -d "$PWD" ]
    then
        >&2 echo "Directory not found: $PWD"
        exit 1
    fi
done

__git_each () {
    local PROJECT_DIR RESULT PROJECT ARGS ARG _RETRIES=$RETRIES
    PROJECT_DIR="$(dirname "$1")"
    cd "$PROJECT_DIR"
    if RESULT=`eval "$GGIT_COND" 2>&1`
    then
        "${ECHO[@]}" "${blue}ENTERING:$normal $yellow$PROJECT_DIR$normal"
        PROJECT="$(basename "$PROJECT_DIR")"
        ARGS=()
        for ARG in "${PARAMS[@]}"
        do
            ARG="${ARG/\{date\}/$DATE}"
            ARG="${ARG/\{datetime\}/$DATETIME}"
            ARG="${ARG/\{project\}/$PROJECT}"
            if [[ "$ARG" == *'$('* ]] || [[ "$ARG" == *'`'* ]]
            then
                ARGS+=(`eval "echo \"$ARG\""`)
            else
                ARGS+=("$ARG")
            fi
        done
        "${CMD[@]}" "${ARGS[@]}" || "${EXIT[@]}"
        while [ "$LAST_EXIT_CODE" == 128 -a $_RETRIES -gt 0 ]
        do
            ((--_RETRIES))
            sleep $(($$%5+1))
            "${CMD[@]}" "${ARGS[@]}" || "${EXIT[@]}"
        done
        "${ECHO[@]}" "${blue}LEAVING:$normal  $PROJECT_DIR"
    elif $VERBOSE
    then
        "${ECHO[@]}" "${blue}ENTERING:$normal $yellow$PROJECT_DIR$normal"
        "${ECHO[@]}" "${magenta}Condition return code:$normal $? ${magenta}Output:$normal"
        [ -n "$RESULT" ] && >&2 echo "$RESULT"
        "${ECHO[@]}" "${blue}LEAVING:$normal  $PROJECT_DIR"
    fi
}

if $SYNC
then
    # Synchronous
    for PWD in "${PWDS[@]}"
    do
        "${ECHO[@]}" "${blue}${bold}BASE DIR:$normal ${bold}$PWD$normal (sync)"
        for DIR in `eval "$FINDER"`
        do
            __git_each "$DIR"
        done
    done
else
    # Asynchronous
    EVAL_ECHO () {
        LAST_EXIT_CODE=$?
        eval "$@"
    }
    declare -A PIDS
    __consume_pid () {
        local PID TMP
        while :
        do
            for PID in ${!PIDS[@]}
            do
                if ! kill -0 $PID 2>/dev/null
                then
                    TMP="${PIDS[$PID]}"
                    cat "$TMP"
                    rm "$TMP"
                    unset PIDS[$PID]
                    return
                fi
            done
            sleep 0.05
        done
    }
    __print_output () {
        while [ ${#PIDS[@]} -gt 0 ]
        do
            __consume_pid
        done
    }
    trap __print_output INT
    for PWD in "${PWDS[@]}"
    do
        "${ECHO[@]}" "${blue}${bold}BASE DIR:$normal ${bold}$PWD$normal (procs=$PROCESSES)"
        for DIR in `eval "$FINDER"`
        do
            TMP="$(mktemp)"
            __git_each "$DIR" 1>"$TMP" 2>&1 &
            PIDS[$!]="$TMP"
            if [ ${#PIDS[@]} -ge $PROCESSES ]
            then
                __consume_pid
            fi
        done
    done
    __print_output
fi
